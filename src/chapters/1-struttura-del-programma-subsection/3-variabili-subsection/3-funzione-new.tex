\documentclass[../../../thesis.tex]{subfiles}
\begin{document}
    \subsubsection{La funzione new}
    Un altro modo per creare una variabile è usare una nuova funzione incorporate.
    L'espressione \verb"new(T)" crea una \textit{variabile senza nome} di tipo \verb"T", inizializzata al valore zero di \verb"T", e restituisce il suo indirizzo, che è un valore di tipo \verb"*T".
    \begin{lstlisting}[frame = single,label={lst:lstlisting1-3-3.1}]
p := new(int) // p, che %*\textit{è}*) di tipo *int, indica una variabile int senza nome
fmt.Println(*p)
*p = 2 // imposta l'int senza nome a 2
fmt.Println(*p)
    \end{lstlisting}
    Output:
    \begin{lstlisting}[language = bash, frame = L,label={lst:lstlisting1-3-3.2}]
0
2
    \end{lstlisting}
    Una variabile creata con la funzione \verb"new" non è diversa da una normale variabile locale se non per l'assenza del nome.
    Questa funzione è usata perché è sintatticamente conveniente per generare dinamicamente un numero illimitato di variabili, come costruire strutture dati complesse e flessibili (per esempio, alberi e grafi).
    Ogni chiamata a \verb"new" restituisce una variabile distinta con un indirizzo univoco:
    \begin{lstlisting}[frame = single,label={lst:lstlisting1-3-3.3}]
p := new(int)
q := new(int)
fmt.Println(p == q)
    \end{lstlisting}
    Output:
    \begin{lstlisting}[language = bash, frame = L,label={lst:lstlisting1-3-3.4}]
false
    \end{lstlisting}
    Tuttavia, c'è un'eccezione a questa regola: due variabili i cui tipi non portano informazioni e la loro dimensione è zero, come \verb"struct{}" o \verb"[0]int", a seconda dell'implementazione possono ottenere lo stesso indirizzo.
    Tuttavia, la funzione \verb"new" è usata raramente perché è più conveniente sfruttare i campi delle struct.
\end{document}