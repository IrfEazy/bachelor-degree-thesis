Dall'inizio degli anni 90, la programmazione orientata agli oggetti (OOP) è stata il paradigma di programmazione dominante nell'industria e nell'istruzione, e quasi tutti i linguaggi ampiamente utilizzati sviluppati da allora hanno offerto supporto a questo approccio.
Go non fa eccezione.

Anche se non esiste una definizione universalmente accettata di programmazione orientata agli oggetti, per i nostri scopi, un \textit{oggetto} è semplicemente un valore o una variabile che ha metodi, e un \textit{metodo} è una funzione associata a un particolare tipo.
Un programma orientato agli oggetti è un programma che utilizza metodi per esprimere le proprietà e le operazioni di ogni struttura dati in modo che i client non debbano accedere direttamente alla rappresentazione dell'oggetto.


\section{Dichiarazioni dei metodi}
\label{sec:dichiarazioni_dei_metodi}%
Un metodo viene dichiarato con una variante della dichiarazione di funzione ordinaria in cui viene visualizzato un parametro aggiuntivo prima del nome della funzione.
Il parametro attribuisce la funzione al tipo di quel parametro.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-1.1}]
package geometry

import %*``*\)math%*''*\)

type Point struct{ X, Y float64 }

// Funzione tradizionale
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// stessa cosa, ma come un metodo del tipo Point
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
\end{lstlisting}
Il parametro extra \verb|p| è chiamato \textit{ricevitore} del metodo, un'eredità dei primi linguaggi orientati agli oggetti che descrivono il chiamare un metodo come ``inviare un messaggio ad un oggetto''.

Dal momento che il nome del ricevitore sarà spesso utilizzato, è una buona idea scegliere qualcosa di breve e di essere coerenti tra i metodi.
Una scelta comune è la prima lettera del nome del tipo, come \verb|p| per \verb|Point|.

In una chiamata di metodo, l'argomento del ricevitore appare prima del nome del metodo.
Questo corrisponde alla dichiarazione, in cui il parametro receiver appare prima del nome del metodo.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-1.2}]
p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // chiamata di funzione
fmt.Println(q.Distance(q))  // chiamata del metodo
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-1.3}]
5
5
\end{lstlisting}
Non c'è conflitto tra le due dichiarazioni di funzioni chiamate \verb|Distance|.
La prima dichiara una funzione a livello di pacchetto chiamata \verb|geometry.Distance|.
La seconda dichiara un metodo del tipo \verb|Point|, quindi il suo nome è \verb|Point.Distance|.

L'espressione \verb|p.Distance| è detta \textit{selettore} perché seleziona il metodo \verb|Distance| appropriato per il ricevitore \verb|p| di tipo \verb|Point|.
I selettori sono anche usati per selezionare i campi dei tipi di struct, come in \verb|p.X|.
Poiché i metodi e i campi abitano lo stesso namespace, dichiarare un metodo \verb|X| sul tipo di struct \verb|Point| sarebbe ambiguo e il compilatore lo rifiuterebbe.

Poiché ogni tipo ha il suo spazio dei nomi per i metodi, possiamo usare il nome \verb|Distance| per altri metodi purché appartengano a diversi tipi.
Definiamo un tipo \verb|Path| assegnandoli anche un metodo \verb|Distance|.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-1.4}]
// Un Path collega i punti con linee rette.
type Path []Point

// Distance restituisce la distanza percorsa lungo il percorso.
func (path Path) Distance() float64 {
    sum := 0.0
    for i := range path {
        if i > 0 {
             sum += path[i-1].Distance(path[i])
        }
    }
    return sum
}
\end{lstlisting}
Chiamiamo il nuovo metodo per calcolare il perimetro di un triangolo retto:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-1.5}]
perim := Path{
    {1, 1},
    {5, 1},
    {5, 4},
    {1, 1},
}
fmt.Println(perim.Distance())
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-1.6}]
12
\end{lstlisting}


\section{Metodi con un ricevitore puntatore}
\label{sec:metodi_con_un_ricevitore_puntatore}%
Poiché la chiamata ad una funzione avvia la copia di ogni valore in input, se una funzione ha bisogno di aggiornare una variabile, o se un argomento è così grande che si vuole evitarne la copia, si deve passare l'indirizzo della variabile usando un puntatore.
Lo stesso vale per i metodi che devono aggiornare la variabile ricevente: devono essere collegati al tipo di puntatore, come \verb|*Point|.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.1}]
func (p *Point) ScaleBy(factor float64) {
   p.X *= factor
   p.Y *= factor
}
\end{lstlisting}
Il nome del metodo è \verb|(*Point).ScaleBy|.
Le parentesi sono necessarie;
senza di esse, l'espressione sarebbe analizzata come \verb|*(Point.ScaleBy)|.

In un programma realistico, la convenzione impone che se un qualsiasi metodo di \verb|Point| ha un ricevitore puntatore, allora \textit{tutti} i metodi di \verb|Point| dovrebbero avere un ricevitore puntatore, anche quelli che non ne hanno strettamente bisogno.

I tipi denominati (\verb|Point|) e i puntatori ad essi (\verb|*Point|) sono gli unici tipi che possono apparire in una dichiarazione del ricevitore.
Inoltre, per evitare ambiguità, le dichiarazioni di metodo non sono consentite su tipi nominati che sono essi stessi tipi di puntatore:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.2}]
type P *int
func (P) f() { /* ... */ } // compile error: tipo di ricevitore
                           // non valido
\end{lstlisting}
Il metodo (*Point).ScaleBy può essere chiamato fornendo un ricevitore *Point, in questo modo:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.3}]
r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r)

p := Point{1, 2}
pptr := &p
pptr.ScaleBy(2)
fmt.Println(p)

t := Point{1, 2}
(&t).ScaleBy(2)
fmt.Println(t)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-2.4}]
{2, 4}
{2, 4}
{2, 4}
\end{lstlisting}
Ma gli ultimi due casi sono sgraziati.
Fortunatamente, il linguaggio favorisce il codice.
Se il ricevitore \verb|p| è una \textit{variabile} di tipo \verb|Point| ma il metodo richiede un ricevitore \verb|*Point|, possiamo usare questa abbreviazione:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.5}]
p.ScaleBy(2)
\end{lstlisting}
e il compilatore eseguirà un \verb|&p| implicito sulla variabile.
Non possiamo chiamare un metodo \verb|*Point| su un ricevitore \verb|Point| non indirizzabile.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.6}]
Point{1, 2}.ScaleBy(2) // compile error: non prende l'indirizzo
                       // di un Point literal
\end{lstlisting}
Ma \textit{possiamo} chiamare un metodo \verb|Point| come \verb|Point.Distance| con un ricevitore \verb|*Point|, perché c'è un modo per ottenere il valore dall'indirizzo: basta caricare il valore indicato dal ricevitore.
Il compilatore inserisce un'operazione \verb|*| implicita per il programmatore.
Le seguenti istruzioni sono equivalenti:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.7}]
pptr.Distance(q)
(*pptr).Distance(q)
\end{lstlisting}

\subsection{Nil è un valore ricevitore valido}
\label{subsec:nil_e_un_valore_ricevitore_valido}%
Proprio come alcune funzioni permettono i puntatori nil come argomenti, così fanno alcuni metodi per il loro ricevitore, specialmente se \verb|nil| è un valore zero significativo del tipo, come con map e slice.
In questa semplice linked list di numeri interi, \verb|nil| rappresenta la lista vuota:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-2.8}]
// Un IntList %*\textit{è}*\) una linked list di interi.
// Un *IntList nil rappresenta la lista vuota.
type IntList struct {
    Value int
    Tail  *IntList
}

// Sum restituisce la somma degli elementi della lista.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}
\end{lstlisting}


\section{Tipi di composizione per Struct Embedding}
\label{sec:tipi_di_composizione_per_struct_embedding}%
Si consideri il tipo \verb|ColoredPoint|:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.1}]
import %*``*\)image/color%*''*\)

type Point struct { X, Y float64 }

type ColoredPoint struct {
    Point
    Color color.RGBA
}
\end{lstlisting}
\verb|Point| è stato \textit{inserito} in \verb|ColoredPoint| per fornire i campi \verb|X| e \verb|Y|.
Se si vuole, si possono selezionare i campi di \verb|ColoredPoint| che sono stati forniti dal \verb|Point| incorporato senza menzionare il \verb|Point|.
Un meccanismo simile si applica ai \textit{metodi} del \verb|Point|.
Si possono chiamare i metodi del campo \verb|Point| incorporato usando un ricevitore di tipo \verb|ColoredPoint|, anche se \verb|ColoredPoint| non ha metodi dichiarati:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.2}]
red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 0, 255, 255}
var p = ColoredPoint{Point{1, 1}, red}
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point))
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point))
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-3.3}]
5
10
\end{lstlisting}
I metodi di \verb|Point| sono stati \textit{promossi} a \verb|ColoredPoint|.
In questo modo, l'embedding permette di costruire tipi complessi con molti metodi mediante la \textit{composizione} di diversi campi, ognuno dei quali fornisce alcuni metodi.

Si osservino le chiamate a \verb|Distance| sopra.
\verb|Distance| ha un parametro di tipo \verb|Point|, e \verb|q| non è un \verb|Point|, quindi anche se \verb|q| ha un campo incorporato di quel tipo, dobbiamo selezionarlo esplicitamente.
Tentare di passare \verb|q| sarebbe un errore:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.4}]
p.Distance(q) // compile error: impossibile usare q
              // (ColoredPoint) come Point
\end{lstlisting}
Il tipo di campo anonimo può essere un \textit{puntatore} a un tipo denominato, nel qual caso i campi e i metodi sono promossi indirettamente dall'oggetto puntato.
L'aggiunta di un altro livello di indirezione ci permette di condividere strutture comuni e variare dinamicamente le relazioni tra gli oggetti.
La dichiarazione di \verb|ColoredPoint| qui sotto incorpora un \verb|*Point|:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.5}]
type ColoredPoint struct {
    *Point
    Color color.RGBA
}

p := ColoredPoint{&Point{1, 1}, red}
q := ColoredPoint{&Point{5, 4}, blue}
fmt.Println(p.Distance(*q.Point))
q.Point = p.Point // p e q ora condividono lo stesso punto
p.ScaleBy(2)
fmt.Println(*p.Pointm *q.Point)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-3.6}]
5
{2, 2} {2, 2}
\end{lstlisting}
Un tipo di struct può avere più di un campo anonimo.
Se avessimo dichiarato ColoredPoint come
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.7}]
type ColoredPoint struct {
    Point
    color.RGBA
}
\end{lstlisting}
un valore di questo tipo avrebbe tutti i metodi di \verb|Point|, tutti i metodi di \verb|RGBA|, e tutti i metodi aggiuntivi dichiarati su \verb|ColoredPoint| direttamente.
Quando il compilatore risolve un selettore come \verb|p.ScaleBy| in un metodo, cerca prima un metodo dichiarato direttamente chiamato \verb|ScaleBy|, poi metodi promossi dai campi embedded di \verb|ColoredPoint|, quindi metodi promossi dai campi embedded all'interno di \verb|Point| e \verb|RGBA|, e così via.
Il compilatore segnala un errore se il selettore è ambiguo perché due metodi sono stati promossi dallo stesso rango.

I metodi possono essere dichiarati solo su tipi nominati (come \verb|Point|) e puntatori ad essi (\verb|*Point|), ma grazie all'embedding, è possibile e talvolta utile che anche i tipi di struct \textit{senza nome} abbiano metodi.

Questo esempio mostra parte di una semplice cache implementata usando due variabili a livello di pacchetto, una mutex e la mappa che custodisce:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.8}]
var (
    mu sync.Mutex // custodisce mapping
    mapping = make(map[string]string)
)
\end{lstlisting}
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.9}]
func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}
\end{lstlisting}
La versione qui sotto è funzionalmente equivalente ma raggruppa insieme le due variabili correlate in una singola variabile a livello di pacchetto, \verb|cache|:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-3.10}]
var cache = struct {
    sync.Mutex
    mapping map[string]string
} {
    mapping: make(map[string]string)
}

func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}
\end{lstlisting}
La nuova variabile dà nomi più espressivi alle variabili relative alla cache, e dato che \verb|sync.Mutex| è incorporato al suo interno, i suoi metodi \verb|Lock| e \verb|Unlock| sono promossi al tipo di struttura senza nome, permettendoci di bloccare la cache con una sintassi auto-esplicativa.


\section{Valori ed espressioni del metodo}
\label{sec:valori_ed_espressioni_del_metodo}%
Di solito si seleziona e si chiama un metodo nella stessa espressione, come in \verb|p.Distance()|, ma è possibile separare queste due operazioni.
Il selettore \verb|p.Distance| produce un \textit{valore del metodo}, una funzione che lega un metodo (\verb|Point.Distance|) a un valore ricevitore specifico \verb|p|.
Questa funzione può essere invocata senza un valore di ricevitore;
ha bisogno solo degli argomenti non riceventi.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-4.1}]
p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance // valore di metodo
fmt.Println(distanceFromP(q))
var origin Point // {0, 0}
fmt.Println(distanceFromP(origin))

scaleP := p.ScaleBy // valore di metodo
scaleP(2)	    // p diventa (2, 4)
scaleP(3)	    // ora (6, 12)
scaleP(10)	    // ora (60, 120)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-4.2}]
5
2.23606797749979
\end{lstlisting}
Correlato al valore del metodo è l'\textit{espressione del metodo}.
Quando si chiama un metodo, al contrario di una funzione ordinaria, bisogna fornire il ricevitore in modo speciale utilizzando la sintassi del selettore.
Un'espressione di metodo, scritta \verb|T.f| o \verb|(*T).f| dove \verb|T| è un tipo, produce un valore di funzione con un primo parametro regolare che prende il posto del ricevitore, quindi può essere chiamato nel modo usuale.
\begin{lstlisting}[frame=single, label={lst:lstlisting5-4.3}]
p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance
fmt.Println(distance(p, q))
fmt.Printf(%*``*\)%T\n%*''*\), distance)

scale := (*Point).ScaleBy
scale(&p, 2)
fmt.Println(p)
fmt.Printf(%*``*\)%T\n%*''*\), scale)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting5-4.4}]
5
func(Point, Point) floa64
{2 4}
func(*Point, float64)
\end{lstlisting}
Le espressioni del metodo possono essere utili quando è necessario un valore per rappresentare una scelta tra diversi metodi appartenenti allo stesso tipo in modo da poter chiamare il metodo scelto con diversi ricevitori.
Nell'esempio seguente la variabile \verb|op| rappresenta l'addizione o il metodo di sottrazione del tipo \verb|Point|, e \verb|Path.TranslateBy| la chiama per ogni punto del \verb|Path|:
\begin{lstlisting}[frame=single, label={lst:lstlisting5-4.5}]
type Point struct { X, Y float64 }

func (p Point) Add(q Point) Point {
    return Point{p.X + q.X, p.Y + q.Y}
}

func (p Point) Sub(q Point) Point {
    return Point{p.X - q.X, p.Y - q.Y}
}

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Chiama o path[i].Add(offset) o path[i].Sub(offset)
        path[i] = op(path[i], offset)
    }
}
\end{lstlisting}


\section{Incapsulamento}
\label{sec:incapsulamento}%
Una variabile o un metodo di un oggetto viene \textit{incapsulato} se è inaccessibile ai client dell'oggetto.
L'incapsulamento, a volte chiamato \textit{occultamento delle informazioni}, è un aspetto chiave della program- mazione orientata agli oggetti.

Go ha un solo meccanismo per controllare la visibilità dei nomi: gli identificatori con il primo carattere maiuscolo vengono esportati dal package in cui sono definiti, e i nomi con il primo carattere non minuscolo non lo sono.
Lo stesso meccanismo che limita l'accesso ai membri di un package limita anche l'accesso ai campi di una struttura o ai metodi di un tipo.
Di conseguenza, per incapsulare un oggetto, bisogna farne una struct.

La conseguenza di questo meccanismo basato sul nome è che l'unità di incapsulamento è il package, non il tipo come in molti altri linguaggi.
I campi di un tipo di struttura sono visibili a tutto il codice all'interno dello stesso package.
Se il codice appare in una funzione o in un metodo non fa alcuna differenza.

L'incapsulamento offre tre vantaggi.
Innanzitutto, poiché i client non possono modificare direttamente le variabili dell'oggetto, è necessario ispezionare un minor numero di istruzioni per comprendere i possibili valori di tali variabili.

In secondo luogo, nascondere i dettagli di implementazione impedisce ai client di dipendere dalle cose che potrebbero cambiare, il che dà al progettista una maggiore libertà di far evolvere l'implementazione senza rompere la compatibilità API\@.

Il terzo vantaggio dell'incapsulamento, e in molti casi il più importante, è che impedisce ai client di impostare arbitrariamente le variabili di un oggetto.
Poiché le variabili dell'oggetto possono essere impostate solo da funzioni nello stesso pacchetto, l'autore di quel pacchetto può assicurare che tutte queste funzioni mantengano gli invarianti interni dell'oggetto.