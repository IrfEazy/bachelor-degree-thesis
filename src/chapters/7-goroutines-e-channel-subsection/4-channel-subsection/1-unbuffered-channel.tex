\documentclass[../../../thesis.tex]{subfiles}
\begin{document}
    \subsubsection{Unbuffered channel}
    Un'operazione di send su un unbuffered channel blocca la goroutine mittente fino a quando un'altra goroutine esegue una corrispondente operazione di receive sullo stesso channel, momento in cui il valore è trasmesso e entrambe le goroutine possono proseguire la loro esecuzione.
    Al contrario, se l'operazione di receive viene eseguita prima, la goroutine destinataria viene bloccata fino a quando un'altra goroutine eseguirà una send sullo stesso channel.
    \hfill \vspace{12pt}

    La comunicazione su un unbuffered channel costringe le goroutine, mittente e destinatario, a \textit{sincronizzarsi}.
    Per questa ragione, gli unbuffered channel sono qualche volta detti channel \textit{sincronizzati}.
    Quando un valore è inviato su un unbuffered channel, la ricezione del valore \textit{avviene prima} del risveglio della goroutine mittente.
    \hfill \vspace{12pt}

    Quando \textit{x} non viene eseguito nè prima di \textit{y} nè dopo \textit{y}, si dice che \textit{x è concorrente ad y}.
    Questo non vuol dire necessariamente che \textit{x} e \textit{y} sono simultanei, piuttosto che non è possibile fare ipotesi sul loro ordine d'esecuzione.
    \hfill \vspace{12pt}

    Per far sì che la main goroutine attenda la fine della goroutine in background prima di chiudere il programma, si può usare un channel per sincronizzare le due goroutine:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting7-4-1.1}]
func main() {
   conn, err := net.Dial("tcp", "localhost:8000")
   if err != nil {
      log.Fatal(err)
   }
   done := make(chan struct{})
   go func() {
      io.Copy(os.Stdout, conn) // NOTA: gli errori sono ignorati
      log.Println("done")
      done <- struct{}{} // si avvisa la main goroutine
   }()
   mustCopy(conn, os.Stdin)
   conn.Close()
   <-done // attende la fine della goroutine in background
}

func mustCopy(dst io.Writer, src io.Reader) {
   if _, err := io.Copy(dst, src); err != nil {
      log.Fatal(err)
   }
}
    \end{lstlisting}
    Quando l'utente chiude lo stream di standard input, \verb"mustCopy" si conclude e la main goroutine chiama \verb"conn.Close()", chiudendo entrambe le parti della connesione alla rete.
    La chiusura del lato scrittura della connessione permette al server di vedere una condizione di end-of-file.
    La chiusura del lato lettura della connessione causa alla chiamata di \verb"io.Copy" sulla goroutine in background di restituire un errore ``read from closed connection" (lettura da una connessione chiusa).
    \hfill \vspace{12pt}

    Prima di restituire il risultato, la goroutine in background registra un messaggio, quindi invia un valore sul channel \verb"done".
    La main goroutine attende di ricevere questo valore prima di restituire anche lei il risultato.
    Come risultato il programma registra sempre il messaggio ``\verb"done"" prima di terminare sul lato client.
    \hfill \vspace{12pt}

    I messaggi inviati sui channel hanno due aspetti importanti.
    Ogni messaggio ha un valore, ma qualche volta sono importanti anche la comunicazione in sè e il momento in cui questa avviene.
    I messaggi sono definiti \textit{eventi} quando si desidera porre accento su quest'aspetto.
    Quando l'evento non porta informazioni aggiuntive allora il suo unico obiettivo è la sincronizzazione, e in questo caso viene usato come tipo elementare del channel il tipo \verb"struct{}", anche se è comune usare un channel di \verb"bool" o \verb"int" per lo stesso obiettivo fintanto che \verb"done <- 1" è più immediato di \verb"done <- struct{}{}".
\end{document}