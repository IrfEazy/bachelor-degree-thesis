\documentclass[../../../thesis.tex]{subfiles}
\begin{document}
    \subsubsection{Tipi di channel unidirezionali}
    Non appena un programma cresce, è naturale spezzare grandi funzioni in pezzi più piccoli.
    La funzione \verb"main" proposta alle pagine precedenti può essere suddivisa in tre funzioni:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting7-4-3.1}]
func counter(out chan int)
func squarer(out, in chan int)
func printer(in chan int)
    \end{lstlisting}
    La funzione \verb"squarer", posto in mezzo alla pipeline, riceve due parametri, il channel di input e il channel di output.
    Entrambi hanno lo stesso tipo, ma i loro usi opposti: \verb"in" è solo per ricevere, mentre \verb"out" solo per inviare.
    I nomi \verb"in" e \verb"out" rafforzano questa idea, ma nulla vieta a \verb"squarer" di inviare su \verb"in" e di ricevere da \verb"out".
    \hfill \vspace{12pt}

    Quando un channel è passato come parametro di una funzione, è quasi sempre dato con l'intento di usarlo esclusivamente per inviare o esclusivamente per ricevere.
    \hfill \vspace{12pt}

    Per documentare questo intento e prevenire un uso scorretto, il type system di Go offre i tipi di channel \textit{unidirezionali} per permettere solo una fra le operazioni di send e receive.
    Il tipo \verb"chan<- int", un channel di \textit{solo invio} di \verb"int", permette solo gli invii.
    Al contrario, il tipo \verb"<-chan int", un channel di \textit{sola ricezione} di \verb"int", permette solo le ricezioni.
    Violazioni di questi usi sono individuati a compile time.
    \hfill \vspace{12pt}

    Dato che l'operazione di \verb"close" asserisce che nessuna operazione di send verrà più effettuata su un channel, allora solo la goroutine mittente potrà chiamarla, e per questa ragione è un errore a compile time provare a chiudere un channel di sola ricezione.
    \begin{lstlisting}[frame = single, label = {lst:lstlisting7-4-3.2}]
func counter(out chan<- int) {
    for x := 0; x < 100; x++ {
        out <- x
    }
    close(out)
}

func squarer(out chan<- int, int <-chan int) {
    for v := range in {
        out <- v * v
    }
    close(out)
}

func printer(in <-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}
    \end{lstlisting}
    \clearpage
    \newpage
    \begin{lstlisting}[frame = single, label = {lst:lstlisting7-4-3.3}]
func main() {
    naturals := make(chan int)
    squares := make(chan int)

    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
    \end{lstlisting}
    La chiamata \verb"counter(naturals)" converte implicitamente \verb"naturals" dal tipo \verb"chan int" al tipo \verb"chan<- int".
    La chiamata a \verb"printer(squares)" esegue implicitamente una conversione simile a \verb"<-chan int".
    Le conversioni dei tipi di channel da bidirezionali a unidirezionali sono permesse in ogni assegnazione.
    Non esiste però modo di tornare indietro: un channel convertito in unidirezionale non può più tornare ad essere bidirezionale.
\end{document}