\section{Nomi}
\label{sec:nomi}%
I nomi delle funzioni, le variabili, le costanti, i tipi, le etichette delle dichiarazioni e i pacchetti in Go seguono una semplice regola: un nome inizia con una lettera (cioè, qualunque cosa Unicode consideri una lettera) o un underscore e poi un qualsiasi numero di lettere, cifre e sottolineature.

Go ha 25 \textit{parole chiave} che non possono essere usate come nomi.
\begin{table}[H]
    \centering
    \begin{tabular}{ l l l l l }
        \verb|break|    & \verb|default|     & \verb|func|   & \verb|interface| & \verb|select| \\
        \verb|case|     & \verb|defer|       & \verb|go|     & \verb|map|       & \verb|struct| \\
        \verb|chan|     & \verb|else|        & \verb|goto|   & \verb|package|   & \verb|switch| \\
        \verb|const|    & \verb|fallthrough| & \verb|if|     & \verb|range|     & \verb|type|   \\
        \verb|continue| & \verb|for|         & \verb|import| & \verb|return|    & \verb|var|
    \end{tabular}
    \label{tab:table11}
\end{table}

Inoltre ci sono nomi \textit{predichiarati} per le costanti, i tipi e le funzioni incorporate.
\begin{table}[H]
    \centering
    \begin{tabular}{ l l }
        Costanti: & \verb|true| \verb|false| \verb|iota| \verb|nil|                                                   \\
        Tipi:     & \verb|int| \verb|int8| \verb|int16| \verb|int32| \verb|int64|                                     \\
        & \verb|uint| \verb|uint8| \verb|uint16| \verb|uint32| \verb|uint64| \verb|uintptr|                 \\
        & \verb|float32| \verb|float64| \verb|complex128| \verb|complex64|                                  \\
        & \verb|bool| \verb|byte| \verb|rune| \verb|string| \verb|error|                                    \\
        Funzioni: & \verb|make| \verb|len| \verb|cap| \verb|new| \verb|append| \verb|copy| \verb|close| \verb|delete| \\
        & \verb|complex| \verb|real| \verb|imag|                                                            \\
        & \verb|panic| \verb|recover|
    \end{tabular}
    \label{tab:table12}
\end{table}
Questi nomi non sono riservati, quindi possono essere utilizzati nelle dichiarazioni.

Quando un'entità è dichiarata all'interno di una funzione, è \textit{locale} a tale funzione.
Se la variabile è dichiarata non funzionante, è visibile a tutti i file nel pacchetto.
La prima lettera di un nome determina la sua visibilità attraverso i pacchetti.
Se il nome inizia con una lettera maiuscola, si dice che sia \textit{esportato} perché è visibile a tutti i pacchetti al di fuori del proprio.
I nomi dei pacchetti sono sempre in minuscolo.

Non ci sono limiti alla lunghezza dei nomi, ma le convenzioni e gli stili nei programmi Go preferiscono i nomi brevi, e se ci sono più parole, la notazione camel-case è preferita rispetto al snake-case.
Quindi si preferisce chiamare le variabili secondo lo stile \verb|archivioRetiPetri|, piuttosto dello stile \verb|archivio_reti_petri|.
Se si desidera inserire acronimi all'interno di un nome, la convenzione richiede l'uso di caratteri minuscoli o solo caratteri maiuscoli;
si preferisce \verb|fileHTML| o una variabile \verb|htmlFile| a una variabile \verb|fileHtml|.


\section{Dichiarazioni}
\label{sec:dichiarazioni}%
Un'istruzione nomina un'entità del programma e specifica alcune o tutte le sue proprietà.
Ci sono quattro tipi di dichiarazioni: \verb|var|, \verb|const|, \verb|type| e \verb|func|.

Un programma Go è archiviato in uno o più file i quali nomi finiscono in \verb|.go|.
Ognuno dei file inizia con una dichiarazione del package che dice di quale package fa parte il file.
La dichiarazione del \verb|package| è seguita da dichiarazioni di \verb|import|, e quindi una sequenza di dichiarazioni di \textit{livello package} di tipi, variabili, costanti, e funzioni, in qualunque ordine.

Per esempio, questo programma dichiara una costante, una funzione, e una coppia di variabili:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-2.1}, literate={°}{\textdegree}1]
package main

import %*``*\)fmt%*''*\)

const boilingF = 212.0

func main() {
    var f = boilingF
    var c = (f - 32) * 5 / 9
    fmt.Printf(%*``*\)boiling point = %g°F or %g°C\n%*''*\), f, c)
}
\end{lstlisting}
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-2.2}, literate={°}{\textdegree}1]
$ ./boiling
boiling point = 212°F o 100°C
\end{lstlisting}
La costante \verb|boilingF| è un'istruzione a livello di pacchetto, quindi tutti i file sorgente nel pacchetto vedranno questa variabile.
Al contrario, la variabile locale \verb|f| è visibile solo alla funzione \verb|main| e nessun altro.


\section{Variabili}
\label{sec:variabili}%
Una dichiarazione di una \verb|var| crea una variabile di un particolare tipo, le dà un nome, e imposta il suo valore iniziale.
Ogni istruzione ha una forma generale:
\begin{lstlisting}[label={lst:lstlisting1-3.1}]
var nome tipo = espressione
\end{lstlisting}
In particolare, può essere omesso uno tra il \verb|tipo| e \verb|= espressione| ma entrambi non possono mancare nella dichiarazione.
Se l'espressione è omessa, il valore iniziale è il valore zero del tipo, vale a dire \verb|0| per i numeri, \verb|false| per il booleano, \verb|""| per le stringhe, e \verb|nil| per le interfacce e i tipi di riferimento (slice, puntatori, mappe, canali, funzioni).
Il valore zero di un tipo aggregato come un array o una struct ha valore zero in tutti i suoi elementi o campi.

Il meccanismo a valore zero assicura che una variabile abbia sempre un valore ben definito del suo tipo;
non ci sono variabili non inizializzate in Go.
Per esempio,
\begin{lstlisting}[frame=single,label={lst:lstlisting1-3.2}]
var s string
\end{lstlisting}
assegna ad \verb|s| una stringa vuota \verb|""|, così da poterlo utilizzare in seguito senza causare errore o comportamento imprevedibile.
I programmatori di Go spesso fanno uno sforzo per rendere significativo il valore zero di un tipo più complicato, in modo che le variabili inizino la loro vita in uno stato utile.

È possibile dichiarare e, facoltativamente, inizializzare un insieme di variabili in una singola dichiarazione, con un elenco di espressioni corrispondenti:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3.3}]
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, %*``*\)four%*''*\)	// bool, float64, string
\end{lstlisting}
Le variabili visibili a livello di pacchetto vengono inizializzate prima dell'avvio del \verb|main|, e le variabili locali vengono inizializzate quando si incontrano le loro dichiarazioni mentre la funzione è in esecuzione.\\
Un insieme di variabili può anche essere inizializzato chiamando una funzione che restituisce più valori:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3.4}]
var f, err = os.Open(name)
\end{lstlisting}
dove \verb|os.Open| restituisce un file e un errore.


\section{Short variable declaration}
\label{sec:short_variable_declaration}%
All'interno di una funzione, una forma alternativa chiamata \textit{short variable declaration} può essere usata per dichiarare e inizializzare le variabili locali.
Questa istruzione assume la forma di \verb|nome := espressione| e il tipo di \verb|nome| è determinato dal tipo di \verb|espressione|.
Esempi di brevi istruzioni di variabili sono:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-1.1}]
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
\end{lstlisting}
A causa della loro compattezza e flessibilità, le short variable declaration sono usate per dichiarare e inizializzare la maggior parte delle variabili locali.
Una dichiarazione \verb|var| tende ad essere riservata alle variabili locali che hanno bisogno di un tipo esplicito diverso da quello dell'espressione di inizializzazione, o per quando alla variabile viene assegnato un valore in seguito e il suo valore iniziale non è importante.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-1.2}]
i := 100                  // un int
var boiling float64 = 100 // un float64

var names []string
var err error
var p Point
\end{lstlisting}
Come per le dichiarazioni \verb|var|, più variabili possono essere dichiarate e inizializzate con la stessa short variable declaration
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-1.3}]
i, j := 0, 1
\end{lstlisting}
ma le istruzioni con più espressioni di inizializzazione dovrebbero essere usate solo quando aiutano la leggibilità.

Va sottolineato che \verb|:=| è una dichiarazione, mentre \verb|=| è un'assegnazione.
Un'istruzione multi-variabile non dovrebbe essere confusa con un'\textit{assegnazione tupla}, in cui ad ogni variabile sul lato sinistro viene assegnato un valore sul lato destro:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-1.4}]
i, j = j, i
\end{lstlisting}
in questo caso si scambiano i valori di \verb|i| e \verb|j|.

Come le normali istruzioni \verb|var|, le short variable declaration possono essere usate per le chiamate di funzione.
Una short variable declaration si comporta come un'assegnazione solo per le variabili che sono già state dichiarate nello stesso blocco lessicale;
le dichiarazioni in blocchi esterni sono ignorate.

\subsection{Puntatori}
\label{subsec:puntatori}%
Una variabile è una parte di un archivio contenente un valore.
Le variabili create dalle dichiarazioni sono identificate da un nome, come \verb|x|, ma la maggior parte delle variabili sono identificate solo da espressioni come \verb|x[i]| o \verb|x.f|.
Tutte queste espressioni leggono il valore di una variabile, tranne quando appaiono sul lato sinistro di un'assegnazione, nel qual caso viene assegnato un nuovo valore alla variabile.

Un valore di un \textit{puntatore} è un \textit{indirizzo} di una variabile.
Un puntatore è quindi la posizione in cui un valore è memorizzato.
Non tutti i valori hanno un indirizzo, ma ogni variabile ne ha uno.
Con un puntatore, è possibile leggere o aggiornare \textit{indirettamente} il valore di una variabile, senza l'uso o la conoscenza del nome di una variabile, sempre ammesso abbia un nome.

Se una variabile è dichiarata \verb|var x int|, l'espressione \verb|&x| (``\verb|x| address'') restituisce un puntatore ad una variabile intera, che è un valore di tipo \verb|*int|, si legge ``pointer to int''.
Se questo valore è definito come \verb|p|, si dirà che ``\verb|p| punta a \verb|x|'', o equivalentemente ``\verb|p| contiene l'indirizzo di \verb|x|''.
La variabile a cui \verb|p| punta è indicata da \verb|*p|.
L'espressione \verb|*p| restituisce il valore di quella variabile, un \verb|int|, ma poiché \verb|*p| denota una variabile, allora può anche apparire a sinistra di un'assegnazione, nel qual caso aggiorna la variabile.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-2.1}]
x := 1
p := &x // p, di tipo *int, punta a x
fmt.Println(*p)
*p = 2 // equivalente a x = 2
fmt.Println(x)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-3-2.2}]
1
2
\end{lstlisting}
Il valore zero di un puntatore per ogni tipo è \verb|nil|.
Se \verb|p| punta a una variabile, allora vale sempre \verb|p != nil|.
I puntatori sono comparabili;
due puntatori sono uguali se e solo se puntano alla stessa variabile o se entrambi sono \verb|nil|.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-2.3}]
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-3-2.4}]
true false false
\end{lstlisting}
Con i puntatori, possiamo ottenere le modifiche alle variabili locali da altre funzioni.
Per esempio,
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-2.5}]
func incr(p *int) int {
    *p++ // incrementa il puntato da p, non cambia p
    return *p
}

func main() {
    v := 1
    incr(&v) // side effect: v vale ora 2
    fmt.Println(incr(&v))
    fmt.Println(v)
}
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-3-2.6}]
3
3
\end{lstlisting}

\subsection{La funzione new}
\label{subsec:la_funzione_new}%
Un altro modo per creare una variabile è usare una nuova funzione incorporate.
L'espressione \verb|new(T)| crea una \textit{variabile senza nome} di tipo \verb|T|, inizializzata al valore zero di \verb|T|, e restituisce il suo indirizzo, che è un valore di tipo \verb|*T|.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-3.1}]
p := new(int) // p, che %*\textit{è}*\) di tipo *int, indica una variabile int
              // senza nome
fmt.Println(*p)
*p = 2 // imposta l'int senza nome a 2
fmt.Println(*p)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-3-3.2}]
0
2
\end{lstlisting}
Una variabile creata con la funzione \verb|new| non è diversa da una normale variabile locale se non per l'assenza del nome.
Questa funzione è usata perché è sintatticamente conveniente per generare dinamicamente un numero illimitato di variabili, come costruire strutture dati complesse e flessibili (per esempio, alberi e grafi).
Ogni chiamata a \verb|new| restituisce una variabile distinta con un indirizzo univoco:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-3.3}]
p := new(int)
q := new(int)
fmt.Println(p == q)
\end{lstlisting}
Output:
\begin{lstlisting}[language=bash, frame=L, label={lst:lstlisting1-3-3.4}]
false
\end{lstlisting}
Tuttavia, c'è un'eccezione a questa regola: due variabili i cui tipi non portano informazioni e la loro dimensione è zero, come \verb|struct{}| o \verb|[0]int|, a seconda dell'implementazione possono ottenere lo stesso indirizzo.
Tuttavia, la funzione \verb|new| è usata raramente perché è più conveniente sfruttare i campi delle struct.

\subsection{La durata delle variabili}
\label{subsec:la_durata_delle_variabili}%
La \textit{durata} della variabile è l'intervallo di tempo durante il quale la variabile esiste durante l'esecuzione del programma.
La durata di una variabile a livello di pacchetto è uguale all'intera esecuzione del programma.
Al contrario, le variabili locali hanno una durata dinamica: una nuova istanza viene creata ogni volta che l'istruzione di dichiarazione viene eseguita, e la variabile vive fino a quando non diventa \textit{irraggiungibile}, momento in cui il suo archivio può essere riciclato.
Anche i parametri e i risultati delle funzioni sono variabili locali;
vengono creati ogni volta che viene chiamata una funzione invece di un parametro.

Ad esempio,
\begin{lstlisting}[frame=single, label={lst:lstlisting1-3-4.1}]
for t := 0.0; t < cycles*2*math.Pi; t += res {
    x := math.Sin(t)
    y := math.Sin(t*freq + phase)
    img.SetColorIndex(size+int(x*size+0.5),
        size+int(y*size+0.5), blackIndex)
}
\end{lstlisting}
la variabile \verb|t| viene creata ogni volta che inizia il ciclo \verb|for|, e le nuove variabili \verb|x| e \verb|y| vengono create ad ogni iterazione del ciclo.

Questo discorso diventa importante per il programmatore in Go, dove spesso fa uso di puntatori a oggetti di breve durata all'interno di oggetti di lunga durata, come variabili globali, perché così facendo impedirà al garbage collector di recuperare gli oggetti di breve durata.


\section{Assegnazioni}
\label{sec:assegnazioni}%
Il valore detenuto da una variabile viene aggiornato da una dichiarazione di assegnazione, che nella sua forma più semplice ha una variabile a sinistra del segno \verb|=| e un'espressione a destra.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-4.1}]
x = 1                       // variabile nominata
*p = true                   // variabile indiretta
person.name = %*``*\)bob%*''*\)         // campo struct
count[x] = count[x] * scale // elemento array o slice o map
\end{lstlisting}

\subsection{Assegnazione di tuple}
\label{subsec:assegnazione_di_tuple}%
Un'altra forma di assegnazione, nota come \textit{assegnazione di tuple}, permette di assegnare più variabili contemporaneamente.
Tutte le espressioni di destra vengono valutate prima che una delle variabili venga aggiornata, rendendo questo modulo più utile quando alcune delle variabili appaiono su entrambi i lati dell'assegnazione, come accade, ad esempio, quando si scambiano i valori di due variabili:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-4-1.1}]
x, y = y, x
a[i], a[j] = a[j], a[i]
\end{lstlisting}
o quando si calcola il massimo comune divisore (MCD) di due interi:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-4-1.2}]
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}
\end{lstlisting}
o quando si calcola iterativamente l'\textit{n}-esimo numero di Fibonacci:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-4-1.3}]
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
\end{lstlisting}

\subsection{Assegnabilità}
\label{subsec:assegnabilita}%
Le istruzioni di assegnazione sono una forma esplicita di assegnazione, ma ci sono molti posti in un programma in cui un'assegnazione avviene \textit{implicitamente}: una chiamata di funzione assegna implicitamente i valori di argomento alle variabili di parametro corrispondenti;
un'istruzione \verb|return| assegna implicitamente gli operandi di \verb|return| alle corrispondenti variabili di risultato.

Un'assegnazione, esplicita o implicita, è sempre legale se il lato sinistro (la variabile) e il lato destro (il valore) hanno lo stesso tipo.
Più in generale, l'assegnazione è legale se solo se il valore è \textit{assegnabile} al tipo di variabile.

Per sapere se due valori possano essere confrontati con \verb|==| e \verb|!=| bisogna vedere la loro assegnabilità: in ogni confronto, il primo operando deve essere assegnabile al tipo del secondo operando, o viceversa.


\section{Dichiarazioni del tipo}
\label{sec:dichiarazioni_del_tipo}%
Il tipo di variabile o espressione definisce le caratteristiche dei valori che può assumere, come la loro dimensione (numero di bit o numero di elementi, forse), come sono rappresentati internamente, le operazioni intrinseche che possono essere eseguite su di essi, e i metodi ad essi associati.

Una dichiarazione di \verb|type| definisce un nuovo \textit{tipo denominato} che ha lo stesso \textit{tipo sottostante} di un tipo esistente.
Il tipo denominato fornisce un modo per separare usi diversi e forse incompatibili del tipo sottostante in modo che non possano essere mescolati involontariamente.
\begin{lstlisting}[label={lst:lstlisting1-5.1}]
type nome tipoSottostante
\end{lstlisting}
Le dichiarazioni di tipo appaiono più spesso a livello di pacchetto, e se il nome viene esportato è accessibile anche da altri pacchetti.
\begin{lstlisting}[frame=single, label={lst:lstlisting1-5.2}]
type Celsius float64
type Fahrenheit float64
\end{lstlisting}
\begin{lstlisting}[frame=single, label={lst:lstlisting1-5.3}]
const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC	  Celsius = 0
    BoilingC	  Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5 / 9)
}
\end{lstlisting}
In questo esempio, sono definiti due tipi denominati, \verb|Celsius| e \verb|Fahrenheit|.
Anche se entrambi hanno lo stesso tipo sottostante, \verb|float64|, non hanno lo stesso tipo, quindi non possono essere comparati o combinati con espressioni aritmetiche.
Un'esplicita \textit{conversione} di tipo, come \verb|Celsius(t)| e \verb|Fahrenheit(t)|, è richiesto per convertire una variabile \verb|t| di tipo \verb|float64|.

Per ogni tipo \verb|T|, c'è una corrispondente operazione di conversione \verb|T(x)| che converte il valore \verb|x| in tipo \verb|T|.
Una conversione da un tipo all'altro è consentita se entrambi hanno lo stesso tipo sottostante, o se entrambi sono tipi di puntatore senza nome che puntano a variabili dello stesso tipo sottostante;
queste conversioni cambiano il tipo ma non la rappresentazione del valore.

Il tipo sottostante di un tipo denominato determina la sua struttura e rappresentazione, e anche l'insieme di operazioni intrinseche che supporta, che sono gli stessi come se il tipo sottostante fosse stato utilizzato direttamente.
Nel caso si facciano comparazioni fra tipi denominati di diverso tipo, allora si ottiene un errore di compilazione per mancata corrispondenza del tipo.

\subsection{Inizializzazione dei pacchetti}
\label{subsec:inizializzazione_dei_pacchetti}%
L'inizializzazione dei pacchetti inizia inizializzando le variabili a livello di pacchetto nell'ordine in cui sono dichiarate, tranne che le dipendenze vengono risolte per prime:
\begin{lstlisting}[frame=single, label={lst:lstlisting1-5-1.1}]
var a = b + c // a %*\textit{è}*\) inizializzato per terzo, a 3
var b = f()   // b %*\textit{è}*\) inizializzato per secondo, a 2, chiamando f
var c = 1     // c %*\textit{è}*\) inizializzato per primo, a 1

func f() int {
    return c + 1
}
\end{lstlisting}
Ogni variabile dichiarata a livello di pacchetto inizia la vita con il valore della sua espressione di inizializzazione, se presente, ma per alcune variabili, come le tabelle di dati, un'espressione di inizializzazione potrebbe non essere il modo più semplice per impostare il suo valore iniziale.
In tal caso, il servizio della funzione \verb|init| può semplificare il lavoro.
Ogni file può contenere la funzione \verb|init| la cui dichiarazione è:
\begin{lstlisting}[label={lst:lstlisting1-5-1.2}]
func init() { codice }
\end{lstlisting}
Tali funzioni di \verb|init| non possono essere chiamate o referenziate, perché altrimenti sarebbero funzioni normali.
All'interno di ogni file, le funzioni di \verb|init| vengono eseguite automaticamente all'avvio del programma, nell'ordine in cui vengono dichiarate.

L'inizializzazione procede dal basso verso l'alto;
il pacchetto principale è l'ultimo ad essere inizializzato.
In questo modo, tutti i pacchetti sono completamente inizializzati prima dell'inizio della funzione principale dell'applicazione.
In particolare, un pacchetto viene inizializzato seguendo l'ordine delle importazioni nel programma, risolvendo prima le dipendenze, quindi un pacchetto \verb|p| che importa \verb|q| può essere certo che \verb|q| sia completamente inizializzato prima che inizi la sua inizializzazione.