\documentclass[../../thesis.tex]{subfiles}
\begin{document}
    \subsection{Struct}\label{subsec:struct}
    Una \textit{struct} è un tipo di dati aggregato che raggruppa insieme zero o più valori denominati di tipi arbitrari in una singola entità.
    Ogni valore è detto \textit{campo}.
    \hfill \vspace{12pt}

    Queste due istruzioni dichiarano un tipo di struct chiamato \verb"Employee" e una variabile chiamata \verb"dilbert" che è un'istanza di un \verb"Employee":
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.1}]
type Employee struct {
    ID 	      int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
    \end{lstlisting}
    I singoli campi di \verb"dilbert" sono accessibili usando la notazione a punti (\verb"dilbert.Name" e \verb"dilbert.DoB").
    Poiché \verb"dilbert" è una variabile, anche i suoi campi sono variabili, quindi possiamo assegnare ad un campo:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.2}]
dilbert.Salary -= 5000
    \end{lstlisting}
    o prendere il suo indirizzo e accedervi tramite un puntatore:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.3}]
position := &dilbert.Position
*position = "Senior " + *position
    \end{lstlisting}
    La notazione a punti funziona anche con un puntatore a una struct:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.4}]
var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player)"
    \end{lstlisting}
    Dove l'ultima istruzione è equivalente a
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.5}]
(*employeeOfTheMonth).Position += " (proactive team player)"
    \end{lstlisting}
    I campi sono di solito scritti uno per riga, con il nome del campo che precede il suo tipo, ma i campi consecutivi dello stesso tipo possono essere combinati, come con \verb"Name" e \verb"Address" qui:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.6}]
type Employee struct {
    ID            int
    Name, Address string
    DoB           time.Time
    Position      string
    Salary        int
    ManagerID     int
}
    \end{lstlisting}
    Un tipo di struct denominato \verb"S" non può dichiarare un campo dello stesso tipo \verb"S": un valore aggregato non può contenere se stesso.
    Ma \verb"S" può dichiarare un campo del tipo di puntatore \verb"*S", che ci permette di creare struct di dati ricorsive come liste concatenate e alberi.
    Questo è illustrato nel codice qui sotto, che utilizza un albero binario per implementare un ordinamento di inserimento:
    \begin{lstlisting}[frame = single, label = {lst:lstlisting3-4.7}]
type tree struct {
    value       int
    left, right *tree
}

// Sorts ordina i valori in posizione.
func Sort(values []int) {
    var root *tree
    for _, v := range values {
        root = add(root, v)
    }
    appendValues(values[:0], root)
}

// appendValues aggiunge gli elementi di t ai valori
// in ordine e restituisce la slice risultante.
func appendValues(values []int, t *tree) []int {
    if t != nil {
        values = appendValues(values, t.left)
        values = append(values, t.value)
        values = appendValues(values, t.right)
    }
    return values
}

func add(t *tree, value int) *tree {
    if t == nil {
        // Equivalente a ritornare &tree{value:value}
        t = new(tree)
        t.value = value
        return t
    }
    if value < t.value {
        t.left = add(t.left, value)
    } else {
        t.right = add(t.right, value)
    }
    return t
}
    \end{lstlisting}
    Il valore zero per una struct è composto dai valori zero di ciascuno dei suoi campi.

    Il tipo di struct senza campi è chiamato \textit{empty struct}, scritto \verb"struct{}".
    \subfile{4-struct-subsection/1-struct-literal}
    \subfile{4-struct-subsection/2-confronto-tra-struct}
    \subfile{4-struct-subsection/3-struct-embedding-e-campi-anonimi}
\end{document}